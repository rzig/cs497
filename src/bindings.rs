/* automatically generated by rust-bindgen 0.65.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 36;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const LEAN_VERSION_MAJOR: u32 = 4;
pub const LEAN_VERSION_MINOR: u32 = 0;
pub const LEAN_VERSION_PATCH: u32 = 0;
pub const LEAN_VERSION_IS_RELEASE: u32 = 0;
pub const LEAN_SPECIAL_VERSION_DESC: &[u8; 19usize] = b"nightly-2022-12-08\0";
pub const LEAN_PACKAGE_VERSION: &[u8; 10usize] = b"NOT-FOUND\0";
pub const LEAN_IS_STAGE0: u32 = 0;
pub const LEAN_CLOSURE_MAX_ARGS: u32 = 16;
pub const LEAN_OBJECT_SIZE_DELTA: u32 = 8;
pub const LEAN_MAX_SMALL_OBJECT_SIZE: u32 = 4096;
pub const LeanMaxCtorTag: u32 = 244;
pub const LeanClosure: u32 = 245;
pub const LeanArray: u32 = 246;
pub const LeanStructArray: u32 = 247;
pub const LeanScalarArray: u32 = 248;
pub const LeanString: u32 = 249;
pub const LeanMPZ: u32 = 250;
pub const LeanThunk: u32 = 251;
pub const LeanTask: u32 = 252;
pub const LeanRef: u32 = 253;
pub const LeanExternal: u32 = 254;
pub const LeanReserved: u32 = 255;
pub const LEAN_MAX_CTOR_FIELDS: u32 = 256;
pub const LEAN_MAX_CTOR_SCALARS_SIZE: u32 = 1024;
pub const LEAN_MAX_SMALL_NAT: i32 = -1;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
extern "C" {
    pub fn lean_notify_assert(
        fileName: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        condition: *const ::std::os::raw::c_char,
    );
}
pub type assertion_failed___FILE___94 = [::std::os::raw::c_char; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lean_object {
    pub m_rc: ::std::os::raw::c_int,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_lean_object() {
    const UNINIT: ::std::mem::MaybeUninit<lean_object> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lean_object>(),
        8usize,
        concat!("Size of: ", stringify!(lean_object))
    );
    assert_eq!(
        ::std::mem::align_of::<lean_object>(),
        4usize,
        concat!("Alignment of ", stringify!(lean_object))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_object),
            "::",
            stringify!(m_rc)
        )
    );
}
impl lean_object {
    #[inline]
    pub fn m_cs_sz(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_m_cs_sz(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn m_other(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_m_other(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn m_tag(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_m_tag(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        m_cs_sz: ::std::os::raw::c_uint,
        m_other: ::std::os::raw::c_uint,
        m_tag: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let m_cs_sz: u32 = unsafe { ::std::mem::transmute(m_cs_sz) };
            m_cs_sz as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let m_other: u32 = unsafe { ::std::mem::transmute(m_other) };
            m_other as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let m_tag: u32 = unsafe { ::std::mem::transmute(m_tag) };
            m_tag as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lean_obj_arg = *mut lean_object;
pub type b_lean_obj_arg = *mut lean_object;
pub type u_lean_obj_arg = *mut lean_object;
pub type lean_obj_res = *mut lean_object;
pub type b_lean_obj_res = *mut lean_object;
#[repr(C)]
#[derive(Debug)]
pub struct lean_ctor_object {
    pub m_header: lean_object,
    pub m_objs: __IncompleteArrayField<*mut lean_object>,
}
#[test]
fn bindgen_test_layout_lean_ctor_object() {
    const UNINIT: ::std::mem::MaybeUninit<lean_ctor_object> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lean_ctor_object>(),
        8usize,
        concat!("Size of: ", stringify!(lean_ctor_object))
    );
    assert_eq!(
        ::std::mem::align_of::<lean_ctor_object>(),
        8usize,
        concat!("Alignment of ", stringify!(lean_ctor_object))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_ctor_object),
            "::",
            stringify!(m_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_objs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_ctor_object),
            "::",
            stringify!(m_objs)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct lean_array_object {
    pub m_header: lean_object,
    pub m_size: usize,
    pub m_capacity: usize,
    pub m_data: __IncompleteArrayField<*mut lean_object>,
}
#[test]
fn bindgen_test_layout_lean_array_object() {
    const UNINIT: ::std::mem::MaybeUninit<lean_array_object> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lean_array_object>(),
        24usize,
        concat!("Size of: ", stringify!(lean_array_object))
    );
    assert_eq!(
        ::std::mem::align_of::<lean_array_object>(),
        8usize,
        concat!("Alignment of ", stringify!(lean_array_object))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_array_object),
            "::",
            stringify!(m_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_array_object),
            "::",
            stringify!(m_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_array_object),
            "::",
            stringify!(m_capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_array_object),
            "::",
            stringify!(m_data)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct lean_sarray_object {
    pub m_header: lean_object,
    pub m_size: usize,
    pub m_capacity: usize,
    pub m_data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_lean_sarray_object() {
    const UNINIT: ::std::mem::MaybeUninit<lean_sarray_object> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lean_sarray_object>(),
        24usize,
        concat!("Size of: ", stringify!(lean_sarray_object))
    );
    assert_eq!(
        ::std::mem::align_of::<lean_sarray_object>(),
        8usize,
        concat!("Alignment of ", stringify!(lean_sarray_object))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_sarray_object),
            "::",
            stringify!(m_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_sarray_object),
            "::",
            stringify!(m_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_sarray_object),
            "::",
            stringify!(m_capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_sarray_object),
            "::",
            stringify!(m_data)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct lean_string_object {
    pub m_header: lean_object,
    pub m_size: usize,
    pub m_capacity: usize,
    pub m_length: usize,
    pub m_data: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_lean_string_object() {
    const UNINIT: ::std::mem::MaybeUninit<lean_string_object> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lean_string_object>(),
        32usize,
        concat!("Size of: ", stringify!(lean_string_object))
    );
    assert_eq!(
        ::std::mem::align_of::<lean_string_object>(),
        8usize,
        concat!("Alignment of ", stringify!(lean_string_object))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_string_object),
            "::",
            stringify!(m_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_string_object),
            "::",
            stringify!(m_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_string_object),
            "::",
            stringify!(m_capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_length) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_string_object),
            "::",
            stringify!(m_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_string_object),
            "::",
            stringify!(m_data)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct lean_closure_object {
    pub m_header: lean_object,
    pub m_fun: *mut ::std::os::raw::c_void,
    pub m_arity: u16,
    pub m_num_fixed: u16,
    pub m_objs: __IncompleteArrayField<*mut lean_object>,
}
#[test]
fn bindgen_test_layout_lean_closure_object() {
    const UNINIT: ::std::mem::MaybeUninit<lean_closure_object> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lean_closure_object>(),
        24usize,
        concat!("Size of: ", stringify!(lean_closure_object))
    );
    assert_eq!(
        ::std::mem::align_of::<lean_closure_object>(),
        8usize,
        concat!("Alignment of ", stringify!(lean_closure_object))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_closure_object),
            "::",
            stringify!(m_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fun) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_closure_object),
            "::",
            stringify!(m_fun)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_arity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_closure_object),
            "::",
            stringify!(m_arity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_num_fixed) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_closure_object),
            "::",
            stringify!(m_num_fixed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_objs) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_closure_object),
            "::",
            stringify!(m_objs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lean_ref_object {
    pub m_header: lean_object,
    pub m_value: *mut lean_object,
}
#[test]
fn bindgen_test_layout_lean_ref_object() {
    const UNINIT: ::std::mem::MaybeUninit<lean_ref_object> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lean_ref_object>(),
        16usize,
        concat!("Size of: ", stringify!(lean_ref_object))
    );
    assert_eq!(
        ::std::mem::align_of::<lean_ref_object>(),
        8usize,
        concat!("Alignment of ", stringify!(lean_ref_object))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_ref_object),
            "::",
            stringify!(m_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_ref_object),
            "::",
            stringify!(m_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lean_thunk_object {
    pub m_header: lean_object,
    pub m_value: u64,
    pub m_closure: u64,
}
#[test]
fn bindgen_test_layout_lean_thunk_object() {
    const UNINIT: ::std::mem::MaybeUninit<lean_thunk_object> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lean_thunk_object>(),
        24usize,
        concat!("Size of: ", stringify!(lean_thunk_object))
    );
    assert_eq!(
        ::std::mem::align_of::<lean_thunk_object>(),
        8usize,
        concat!("Alignment of ", stringify!(lean_thunk_object))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_thunk_object),
            "::",
            stringify!(m_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_thunk_object),
            "::",
            stringify!(m_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_closure) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_thunk_object),
            "::",
            stringify!(m_closure)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lean_task_imp {
    pub m_closure: *mut lean_object,
    pub m_head_dep: *mut lean_task,
    pub m_next_dep: *mut lean_task,
    pub m_prio: ::std::os::raw::c_uint,
    pub m_canceled: u8,
    pub m_keep_alive: u8,
    pub m_deleted: u8,
}
#[test]
fn bindgen_test_layout_lean_task_imp() {
    const UNINIT: ::std::mem::MaybeUninit<lean_task_imp> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lean_task_imp>(),
        32usize,
        concat!("Size of: ", stringify!(lean_task_imp))
    );
    assert_eq!(
        ::std::mem::align_of::<lean_task_imp>(),
        8usize,
        concat!("Alignment of ", stringify!(lean_task_imp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_closure) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_task_imp),
            "::",
            stringify!(m_closure)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_head_dep) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_task_imp),
            "::",
            stringify!(m_head_dep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_next_dep) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_task_imp),
            "::",
            stringify!(m_next_dep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_prio) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_task_imp),
            "::",
            stringify!(m_prio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_canceled) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_task_imp),
            "::",
            stringify!(m_canceled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_keep_alive) as usize - ptr as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_task_imp),
            "::",
            stringify!(m_keep_alive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_deleted) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_task_imp),
            "::",
            stringify!(m_deleted)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lean_task {
    pub m_header: lean_object,
    pub m_value: u64,
    pub m_imp: *mut lean_task_imp,
}
#[test]
fn bindgen_test_layout_lean_task() {
    const UNINIT: ::std::mem::MaybeUninit<lean_task> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lean_task>(),
        24usize,
        concat!("Size of: ", stringify!(lean_task))
    );
    assert_eq!(
        ::std::mem::align_of::<lean_task>(),
        8usize,
        concat!("Alignment of ", stringify!(lean_task))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_task),
            "::",
            stringify!(m_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_task),
            "::",
            stringify!(m_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_imp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_task),
            "::",
            stringify!(m_imp)
        )
    );
}
pub type lean_task_object = lean_task;
pub type lean_external_finalize_proc =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
pub type lean_external_foreach_proc = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: b_lean_obj_arg),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lean_external_class {
    pub m_finalize: lean_external_finalize_proc,
    pub m_foreach: lean_external_foreach_proc,
}
#[test]
fn bindgen_test_layout_lean_external_class() {
    const UNINIT: ::std::mem::MaybeUninit<lean_external_class> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lean_external_class>(),
        16usize,
        concat!("Size of: ", stringify!(lean_external_class))
    );
    assert_eq!(
        ::std::mem::align_of::<lean_external_class>(),
        8usize,
        concat!("Alignment of ", stringify!(lean_external_class))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_finalize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_external_class),
            "::",
            stringify!(m_finalize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_foreach) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_external_class),
            "::",
            stringify!(m_foreach)
        )
    );
}
extern "C" {
    pub fn lean_register_external_class(
        arg1: lean_external_finalize_proc,
        arg2: lean_external_foreach_proc,
    ) -> *mut lean_external_class;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lean_external_object {
    pub m_header: lean_object,
    pub m_class: *mut lean_external_class,
    pub m_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_lean_external_object() {
    const UNINIT: ::std::mem::MaybeUninit<lean_external_object> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lean_external_object>(),
        24usize,
        concat!("Size of: ", stringify!(lean_external_object))
    );
    assert_eq!(
        ::std::mem::align_of::<lean_external_object>(),
        8usize,
        concat!("Alignment of ", stringify!(lean_external_object))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_external_object),
            "::",
            stringify!(m_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_class) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_external_object),
            "::",
            stringify!(m_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_external_object),
            "::",
            stringify!(m_data)
        )
    );
}
extern "C" {
    pub fn lean_set_exit_on_panic(flag: bool);
}
extern "C" {
    pub fn lean_set_panic_messages(flag: bool);
}
extern "C" {
    pub fn lean_panic_fn(default_val: *mut lean_object, msg: *mut lean_object) -> *mut lean_object;
}
extern "C" {
    pub fn lean_internal_panic(msg: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    pub fn lean_internal_panic_out_of_memory() -> !;
}
extern "C" {
    pub fn lean_internal_panic_unreachable() -> !;
}
extern "C" {
    pub fn lean_internal_panic_rc_overflow() -> !;
}
extern "C" {
    pub fn lean_alloc_small(
        sz: ::std::os::raw::c_uint,
        slot_idx: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lean_free_small(p: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn lean_small_mem_size(p: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn lean_inc_heartbeat();
}
extern "C" {
    pub fn malloc(arg1: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn lean_alloc_object(sz: usize) -> *mut lean_object;
}
extern "C" {
    pub fn lean_free_object(o: *mut lean_object);
}
extern "C" {
    pub fn lean_object_byte_size(o: *mut lean_object) -> usize;
}
extern "C" {
    pub fn lean_inc_ref_cold(o: *mut lean_object);
}
extern "C" {
    pub fn lean_inc_ref_n_cold(o: *mut lean_object, n: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn lean_dec_ref_cold(o: *mut lean_object);
}
extern "C" {
    pub fn lean_dealloc(o: *mut lean_object);
}
extern "C" {
    pub fn lean_mark_mt(o: *mut lean_object);
}
extern "C" {
    pub fn lean_mark_persistent(o: *mut lean_object);
}
extern "C" {
    pub fn lean_apply_1(f: *mut lean_object, a1: *mut lean_object) -> *mut lean_object;
}
extern "C" {
    pub fn lean_apply_2(
        f: *mut lean_object,
        a1: *mut lean_object,
        a2: *mut lean_object,
    ) -> *mut lean_object;
}
extern "C" {
    pub fn lean_apply_3(
        f: *mut lean_object,
        a1: *mut lean_object,
        a2: *mut lean_object,
        a3: *mut lean_object,
    ) -> *mut lean_object;
}
extern "C" {
    pub fn lean_apply_4(
        f: *mut lean_object,
        a1: *mut lean_object,
        a2: *mut lean_object,
        a3: *mut lean_object,
        a4: *mut lean_object,
    ) -> *mut lean_object;
}
extern "C" {
    pub fn lean_apply_5(
        f: *mut lean_object,
        a1: *mut lean_object,
        a2: *mut lean_object,
        a3: *mut lean_object,
        a4: *mut lean_object,
        a5: *mut lean_object,
    ) -> *mut lean_object;
}
extern "C" {
    pub fn lean_apply_6(
        f: *mut lean_object,
        a1: *mut lean_object,
        a2: *mut lean_object,
        a3: *mut lean_object,
        a4: *mut lean_object,
        a5: *mut lean_object,
        a6: *mut lean_object,
    ) -> *mut lean_object;
}
extern "C" {
    pub fn lean_apply_7(
        f: *mut lean_object,
        a1: *mut lean_object,
        a2: *mut lean_object,
        a3: *mut lean_object,
        a4: *mut lean_object,
        a5: *mut lean_object,
        a6: *mut lean_object,
        a7: *mut lean_object,
    ) -> *mut lean_object;
}
extern "C" {
    pub fn lean_apply_8(
        f: *mut lean_object,
        a1: *mut lean_object,
        a2: *mut lean_object,
        a3: *mut lean_object,
        a4: *mut lean_object,
        a5: *mut lean_object,
        a6: *mut lean_object,
        a7: *mut lean_object,
        a8: *mut lean_object,
    ) -> *mut lean_object;
}
extern "C" {
    pub fn lean_apply_9(
        f: *mut lean_object,
        a1: *mut lean_object,
        a2: *mut lean_object,
        a3: *mut lean_object,
        a4: *mut lean_object,
        a5: *mut lean_object,
        a6: *mut lean_object,
        a7: *mut lean_object,
        a8: *mut lean_object,
        a9: *mut lean_object,
    ) -> *mut lean_object;
}
extern "C" {
    pub fn lean_apply_10(
        f: *mut lean_object,
        a1: *mut lean_object,
        a2: *mut lean_object,
        a3: *mut lean_object,
        a4: *mut lean_object,
        a5: *mut lean_object,
        a6: *mut lean_object,
        a7: *mut lean_object,
        a8: *mut lean_object,
        a9: *mut lean_object,
        a10: *mut lean_object,
    ) -> *mut lean_object;
}
extern "C" {
    pub fn lean_apply_11(
        f: *mut lean_object,
        a1: *mut lean_object,
        a2: *mut lean_object,
        a3: *mut lean_object,
        a4: *mut lean_object,
        a5: *mut lean_object,
        a6: *mut lean_object,
        a7: *mut lean_object,
        a8: *mut lean_object,
        a9: *mut lean_object,
        a10: *mut lean_object,
        a11: *mut lean_object,
    ) -> *mut lean_object;
}
extern "C" {
    pub fn lean_apply_12(
        f: *mut lean_object,
        a1: *mut lean_object,
        a2: *mut lean_object,
        a3: *mut lean_object,
        a4: *mut lean_object,
        a5: *mut lean_object,
        a6: *mut lean_object,
        a7: *mut lean_object,
        a8: *mut lean_object,
        a9: *mut lean_object,
        a10: *mut lean_object,
        a11: *mut lean_object,
        a12: *mut lean_object,
    ) -> *mut lean_object;
}
extern "C" {
    pub fn lean_apply_13(
        f: *mut lean_object,
        a1: *mut lean_object,
        a2: *mut lean_object,
        a3: *mut lean_object,
        a4: *mut lean_object,
        a5: *mut lean_object,
        a6: *mut lean_object,
        a7: *mut lean_object,
        a8: *mut lean_object,
        a9: *mut lean_object,
        a10: *mut lean_object,
        a11: *mut lean_object,
        a12: *mut lean_object,
        a13: *mut lean_object,
    ) -> *mut lean_object;
}
extern "C" {
    pub fn lean_apply_14(
        f: *mut lean_object,
        a1: *mut lean_object,
        a2: *mut lean_object,
        a3: *mut lean_object,
        a4: *mut lean_object,
        a5: *mut lean_object,
        a6: *mut lean_object,
        a7: *mut lean_object,
        a8: *mut lean_object,
        a9: *mut lean_object,
        a10: *mut lean_object,
        a11: *mut lean_object,
        a12: *mut lean_object,
        a13: *mut lean_object,
        a14: *mut lean_object,
    ) -> *mut lean_object;
}
extern "C" {
    pub fn lean_apply_15(
        f: *mut lean_object,
        a1: *mut lean_object,
        a2: *mut lean_object,
        a3: *mut lean_object,
        a4: *mut lean_object,
        a5: *mut lean_object,
        a6: *mut lean_object,
        a7: *mut lean_object,
        a8: *mut lean_object,
        a9: *mut lean_object,
        a10: *mut lean_object,
        a11: *mut lean_object,
        a12: *mut lean_object,
        a13: *mut lean_object,
        a14: *mut lean_object,
        a15: *mut lean_object,
    ) -> *mut lean_object;
}
extern "C" {
    pub fn lean_apply_16(
        f: *mut lean_object,
        a1: *mut lean_object,
        a2: *mut lean_object,
        a3: *mut lean_object,
        a4: *mut lean_object,
        a5: *mut lean_object,
        a6: *mut lean_object,
        a7: *mut lean_object,
        a8: *mut lean_object,
        a9: *mut lean_object,
        a10: *mut lean_object,
        a11: *mut lean_object,
        a12: *mut lean_object,
        a13: *mut lean_object,
        a14: *mut lean_object,
        a15: *mut lean_object,
        a16: *mut lean_object,
    ) -> *mut lean_object;
}
extern "C" {
    pub fn lean_apply_n(
        f: *mut lean_object,
        n: ::std::os::raw::c_uint,
        args: *mut *mut lean_object,
    ) -> *mut lean_object;
}
extern "C" {
    pub fn lean_apply_m(
        f: *mut lean_object,
        n: ::std::os::raw::c_uint,
        args: *mut *mut lean_object,
    ) -> *mut lean_object;
}
extern "C" {
    pub fn lean_array_mk(l: lean_obj_arg) -> *mut lean_object;
}
extern "C" {
    pub fn lean_array_data(a: lean_obj_arg) -> *mut lean_object;
}
extern "C" {
    pub fn lean_array_get_panic(def_val: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_copy_expand_array(a: lean_obj_arg, expand: bool) -> lean_obj_res;
}
extern "C" {
    pub fn lean_array_set_panic(a: lean_obj_arg, v: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_array_push(a: lean_obj_arg, v: lean_obj_arg) -> *mut lean_object;
}
extern "C" {
    pub fn lean_mk_array(n: lean_obj_arg, v: lean_obj_arg) -> *mut lean_object;
}
extern "C" {
    pub fn lean_byte_array_mk(a: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_byte_array_data(a: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_copy_byte_array(a: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_byte_array_hash(a: b_lean_obj_arg) -> u64;
}
extern "C" {
    pub fn lean_byte_array_push(a: lean_obj_arg, b: u8) -> lean_obj_res;
}
extern "C" {
    pub fn lean_float_array_mk(a: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_float_array_data(a: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_copy_float_array(a: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_float_array_push(a: lean_obj_arg, d: f64) -> lean_obj_res;
}
extern "C" {
    pub fn lean_utf8_strlen(str_: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn lean_utf8_n_strlen(str_: *const ::std::os::raw::c_char, n: usize) -> usize;
}
extern "C" {
    pub fn lean_mk_string_from_bytes(s: *const ::std::os::raw::c_char, sz: usize) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_string(s: *const ::std::os::raw::c_char) -> lean_obj_res;
}
extern "C" {
    pub fn lean_string_push(s: lean_obj_arg, c: u32) -> lean_obj_res;
}
extern "C" {
    pub fn lean_string_append(s1: lean_obj_arg, s2: b_lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_string_mk(cs: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_string_data(s: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_string_utf8_get(s: b_lean_obj_arg, i: b_lean_obj_arg) -> u32;
}
extern "C" {
    pub fn lean_string_utf8_get_fast_cold(
        str_: *const ::std::os::raw::c_char,
        i: usize,
        size: usize,
        c: ::std::os::raw::c_uchar,
    ) -> u32;
}
extern "C" {
    pub fn lean_string_utf8_next(s: b_lean_obj_arg, i: b_lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_string_utf8_next_fast_cold(i: usize, c: ::std::os::raw::c_uchar) -> lean_obj_res;
}
extern "C" {
    pub fn lean_string_utf8_prev(s: b_lean_obj_arg, i: b_lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_string_utf8_set(s: lean_obj_arg, i: b_lean_obj_arg, c: u32) -> lean_obj_res;
}
extern "C" {
    pub fn lean_string_utf8_extract(
        s: b_lean_obj_arg,
        b: b_lean_obj_arg,
        e: b_lean_obj_arg,
    ) -> lean_obj_res;
}
extern "C" {
    pub fn lean_string_eq_cold(s1: b_lean_obj_arg, s2: b_lean_obj_arg) -> bool;
}
extern "C" {
    pub fn lean_string_lt(s1: b_lean_obj_arg, s2: b_lean_obj_arg) -> bool;
}
extern "C" {
    pub fn lean_string_hash(arg1: b_lean_obj_arg) -> u64;
}
extern "C" {
    pub fn lean_thunk_get_core(t: *mut lean_object) -> *mut lean_object;
}
extern "C" {
    pub fn lean_init_task_manager();
}
extern "C" {
    pub fn lean_init_task_manager_using(num_workers: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn lean_finalize_task_manager();
}
extern "C" {
    pub fn lean_task_spawn_core(
        c: lean_obj_arg,
        prio: ::std::os::raw::c_uint,
        keep_alive: bool,
    ) -> lean_obj_res;
}
extern "C" {
    pub fn lean_task_pure(a: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_task_bind_core(
        x: lean_obj_arg,
        f: lean_obj_arg,
        prio: ::std::os::raw::c_uint,
        keep_alive: bool,
    ) -> lean_obj_res;
}
extern "C" {
    pub fn lean_task_map_core(
        f: lean_obj_arg,
        t: lean_obj_arg,
        prio: ::std::os::raw::c_uint,
        keep_alive: bool,
    ) -> lean_obj_res;
}
extern "C" {
    pub fn lean_task_get(t: b_lean_obj_arg) -> b_lean_obj_res;
}
extern "C" {
    pub fn lean_io_check_canceled_core() -> bool;
}
extern "C" {
    pub fn lean_io_cancel_core(t: b_lean_obj_arg);
}
extern "C" {
    pub fn lean_io_has_finished_core(t: b_lean_obj_arg) -> bool;
}
extern "C" {
    pub fn lean_io_wait_any_core(task_list: b_lean_obj_arg) -> b_lean_obj_res;
}
extern "C" {
    pub fn lean_nat_big_succ(a: *mut lean_object) -> *mut lean_object;
}
extern "C" {
    pub fn lean_nat_big_add(a1: *mut lean_object, a2: *mut lean_object) -> *mut lean_object;
}
extern "C" {
    pub fn lean_nat_big_sub(a1: *mut lean_object, a2: *mut lean_object) -> *mut lean_object;
}
extern "C" {
    pub fn lean_nat_big_mul(a1: *mut lean_object, a2: *mut lean_object) -> *mut lean_object;
}
extern "C" {
    pub fn lean_nat_overflow_mul(a1: usize, a2: usize) -> *mut lean_object;
}
extern "C" {
    pub fn lean_nat_big_div(a1: *mut lean_object, a2: *mut lean_object) -> *mut lean_object;
}
extern "C" {
    pub fn lean_nat_big_mod(a1: *mut lean_object, a2: *mut lean_object) -> *mut lean_object;
}
extern "C" {
    pub fn lean_nat_big_eq(a1: *mut lean_object, a2: *mut lean_object) -> bool;
}
extern "C" {
    pub fn lean_nat_big_le(a1: *mut lean_object, a2: *mut lean_object) -> bool;
}
extern "C" {
    pub fn lean_nat_big_lt(a1: *mut lean_object, a2: *mut lean_object) -> bool;
}
extern "C" {
    pub fn lean_nat_big_land(a1: *mut lean_object, a2: *mut lean_object) -> *mut lean_object;
}
extern "C" {
    pub fn lean_nat_big_lor(a1: *mut lean_object, a2: *mut lean_object) -> *mut lean_object;
}
extern "C" {
    pub fn lean_nat_big_xor(a1: *mut lean_object, a2: *mut lean_object) -> *mut lean_object;
}
extern "C" {
    pub fn lean_cstr_to_nat(n: *const ::std::os::raw::c_char) -> lean_obj_res;
}
extern "C" {
    pub fn lean_big_usize_to_nat(n: usize) -> lean_obj_res;
}
extern "C" {
    pub fn lean_big_uint64_to_nat(n: u64) -> lean_obj_res;
}
extern "C" {
    pub fn lean_nat_shiftl(a1: b_lean_obj_arg, a2: b_lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_nat_shiftr(a1: b_lean_obj_arg, a2: b_lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_nat_pow(a1: b_lean_obj_arg, a2: b_lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_nat_gcd(a1: b_lean_obj_arg, a2: b_lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_nat_log2(a: b_lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_int_big_neg(a: *mut lean_object) -> *mut lean_object;
}
extern "C" {
    pub fn lean_int_big_add(a1: *mut lean_object, a2: *mut lean_object) -> *mut lean_object;
}
extern "C" {
    pub fn lean_int_big_sub(a1: *mut lean_object, a2: *mut lean_object) -> *mut lean_object;
}
extern "C" {
    pub fn lean_int_big_mul(a1: *mut lean_object, a2: *mut lean_object) -> *mut lean_object;
}
extern "C" {
    pub fn lean_int_big_div(a1: *mut lean_object, a2: *mut lean_object) -> *mut lean_object;
}
extern "C" {
    pub fn lean_int_big_mod(a1: *mut lean_object, a2: *mut lean_object) -> *mut lean_object;
}
extern "C" {
    pub fn lean_int_big_eq(a1: *mut lean_object, a2: *mut lean_object) -> bool;
}
extern "C" {
    pub fn lean_int_big_le(a1: *mut lean_object, a2: *mut lean_object) -> bool;
}
extern "C" {
    pub fn lean_int_big_lt(a1: *mut lean_object, a2: *mut lean_object) -> bool;
}
extern "C" {
    pub fn lean_int_big_nonneg(a: *mut lean_object) -> bool;
}
extern "C" {
    pub fn lean_cstr_to_int(n: *const ::std::os::raw::c_char) -> *mut lean_object;
}
extern "C" {
    pub fn lean_big_int_to_int(n: ::std::os::raw::c_int) -> *mut lean_object;
}
extern "C" {
    pub fn lean_big_size_t_to_int(n: usize) -> *mut lean_object;
}
extern "C" {
    pub fn lean_big_int64_to_int(n: i64) -> *mut lean_object;
}
extern "C" {
    pub fn lean_big_int_to_nat(a: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_uint8_of_big_nat(a: b_lean_obj_arg) -> u8;
}
extern "C" {
    pub fn lean_uint16_of_big_nat(a: b_lean_obj_arg) -> u16;
}
extern "C" {
    pub fn lean_uint32_of_big_nat(a: b_lean_obj_arg) -> u32;
}
extern "C" {
    pub fn lean_uint32_big_modn(a1: u32, a2: b_lean_obj_arg) -> u32;
}
extern "C" {
    pub fn lean_uint64_of_big_nat(a: b_lean_obj_arg) -> u64;
}
extern "C" {
    pub fn lean_uint64_big_modn(a1: u64, a2: b_lean_obj_arg) -> u64;
}
extern "C" {
    pub fn lean_uint64_mix_hash(a1: u64, a2: u64) -> u64;
}
extern "C" {
    pub fn lean_usize_of_big_nat(a: b_lean_obj_arg) -> usize;
}
extern "C" {
    pub fn lean_usize_big_modn(a1: usize, a2: b_lean_obj_arg) -> usize;
}
extern "C" {
    pub fn lean_float_to_string(a: f64) -> lean_obj_res;
}
extern "C" {
    pub fn lean_float_scaleb(a: f64, b: b_lean_obj_arg) -> f64;
}
extern "C" {
    pub fn lean_float_isnan(a: f64) -> u8;
}
extern "C" {
    pub fn lean_float_isfinite(a: f64) -> u8;
}
extern "C" {
    pub fn lean_float_isinf(a: f64) -> u8;
}
extern "C" {
    pub fn lean_float_frexp(a: f64) -> lean_obj_res;
}
extern "C" {
    pub fn lean_dbg_trace(s: lean_obj_arg, fn_: lean_obj_arg) -> *mut lean_object;
}
extern "C" {
    pub fn lean_dbg_sleep(ms: u32, fn_: lean_obj_arg) -> *mut lean_object;
}
extern "C" {
    pub fn lean_dbg_trace_if_shared(s: lean_obj_arg, a: lean_obj_arg) -> *mut lean_object;
}
extern "C" {
    pub fn lean_decode_io_error(
        errnum: ::std::os::raw::c_int,
        fname: b_lean_obj_arg,
    ) -> lean_obj_res;
}
extern "C" {
    pub fn lean_io_result_show_error(r: b_lean_obj_arg);
}
extern "C" {
    pub fn lean_io_mark_end_initialization();
}
extern "C" {
    pub fn lean_mk_io_error_already_exists(arg1: u32, arg2: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_already_exists_file(
        arg1: lean_obj_arg,
        arg2: u32,
        arg3: lean_obj_arg,
    ) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_eof(arg1: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_hardware_fault(arg1: u32, arg2: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_illegal_operation(arg1: u32, arg2: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_inappropriate_type(arg1: u32, arg2: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_inappropriate_type_file(
        arg1: lean_obj_arg,
        arg2: u32,
        arg3: lean_obj_arg,
    ) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_interrupted(
        arg1: lean_obj_arg,
        arg2: u32,
        arg3: lean_obj_arg,
    ) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_invalid_argument(arg1: u32, arg2: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_invalid_argument_file(
        arg1: lean_obj_arg,
        arg2: u32,
        arg3: lean_obj_arg,
    ) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_no_file_or_directory(
        arg1: lean_obj_arg,
        arg2: u32,
        arg3: lean_obj_arg,
    ) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_no_such_thing(arg1: u32, arg2: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_no_such_thing_file(
        arg1: lean_obj_arg,
        arg2: u32,
        arg3: lean_obj_arg,
    ) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_other_error(arg1: u32, arg2: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_permission_denied(arg1: u32, arg2: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_permission_denied_file(
        arg1: lean_obj_arg,
        arg2: u32,
        arg3: lean_obj_arg,
    ) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_protocol_error(arg1: u32, arg2: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_resource_busy(arg1: u32, arg2: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_resource_exhausted(arg1: u32, arg2: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_resource_exhausted_file(
        arg1: lean_obj_arg,
        arg2: u32,
        arg3: lean_obj_arg,
    ) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_resource_vanished(arg1: u32, arg2: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_time_expired(arg1: u32, arg2: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_unsatisfied_constraints(arg1: u32, arg2: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_unsupported_operation(arg1: u32, arg2: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_user_error(str_: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_st_mk_ref(arg1: lean_obj_arg, arg2: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_st_ref_get(arg1: b_lean_obj_arg, arg2: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_st_ref_set(
        arg1: b_lean_obj_arg,
        arg2: lean_obj_arg,
        arg3: lean_obj_arg,
    ) -> lean_obj_res;
}
extern "C" {
    pub fn lean_st_ref_reset(arg1: b_lean_obj_arg, arg2: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_st_ref_swap(
        arg1: b_lean_obj_arg,
        arg2: lean_obj_arg,
        arg3: lean_obj_arg,
    ) -> lean_obj_res;
}
extern "C" {
    pub fn lean_name_eq(n1: b_lean_obj_arg, n2: b_lean_obj_arg) -> u8;
}
